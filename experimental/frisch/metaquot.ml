(* A -ppx rewriter to be used to write Parsetree-generating code
   (including other -ppx rewriters) using concrete syntax.

   See metaquot_test.ml for an example.

   We support the following extensions in expression position:

   [%expr ...]  maps to code which creates the expression represented by ...
   [%pat "..."] maps to code which creates the pattern represented by ...
   [%pat "..."] maps to code which creates the pattern represented by ...
   [%str "..."] maps to code which creates the structure represented by ...
   [type "..."] maps to code which creates the core type represented by ...

   Note that except for the expr expander, the argument needs to be
   a string literal (it can also be a quoted string, of course), which
   will be re-parse by the expander (in case of a parsing error,
   the location will be relative to the parsed string).

   Quoted code can refer to expressions representing AST fragments,
   using the following extensions:

     [%e ...] where ... is an expression of type Parsetree.expression
     [%t ...] where ... is an expression of type Parsetree.core_type
     [%p ...] where ... is an expression of type Parsetree.pattern


   All locations generated by the meta quotation are by default set
   to Location.none.  This can be overriden by providing a custom
   expression which will be inserted whereever a location is required
   in the generated AST.  This expression can be specified globally
   (for the current structure) as a structure item attribute:

     ;;[@@metaloc ...]

   or locally for the scope of an expression:

     e [@metaloc ...]

   No support is provided for meta quotation in pattern position.
*)

module Main : sig end = struct
  open Asttypes
  open Parsetree
  open Ast_helper
  open Ast_helper.Convenience

  let prefix ty s =
    let open Longident in
    match parse ty with
    | Ldot(m, _) -> String.concat "." (Longident.flatten m) ^ "." ^ s
    | _ -> s

  class exp_builder =
    object
      method record ty x =
        Exp.record (List.map (fun (l, e) -> lid (prefix ty l), e) x) None
      method constr ty (c, args) = constr (prefix ty c) args
      method list = list
      method tuple l = Exp.tuple l
      method int x = Exp.constant (Const_int x)
      method string = str
      method char x = Exp.constant (Const_char x)
      method int32 x = Exp.constant (Const_int32 x)
      method int64 x = Exp.constant (Const_int64 x)
      method nativeint x = Exp.constant (Const_nativeint x)
    end


  let lifter loc =
    object
      inherit [_] Ast_lifter.lifter as super
      inherit exp_builder

          (* Special support for location in the generated AST *)
      method! lift_Location_t _ = loc

          (* Support for antiquotations *)
      method! lift_Parsetree_expression = function
        | {pexp_desc=Pexp_extension("e", e); _} -> e
        | x -> super # lift_Parsetree_expression x

      method! lift_Parsetree_pattern = function
        | {ppat_desc=Ppat_extension("p", e); _} -> e
        | x -> super # lift_Parsetree_pattern x

      method! lift_Parsetree_core_type = function
        | {ptyp_desc=Ptyp_extension("t", e); _} -> e
        | x -> super # lift_Parsetree_core_type x
    end

  let loc = ref (evar "Location.none")
  let handle_attr = function
    | "metaloc", l -> loc := l
    | _ -> ()

  let with_loc ?(attrs = []) f =
    let old_loc = !loc in
    List.iter handle_attr attrs;
    let r = f () in
    loc := old_loc;
    r

  let report_error ppf exn =
    let report ppf = function
      | Lexer.Error(err, loc) ->
          Location.print_error ppf loc;
          Lexer.report_error ppf err
      | Syntaxerr.Error err ->
          Syntaxerr.report_error ppf err
      | x ->
          Format.fprintf ppf "%s" (Printexc.to_string x)
    in
    Format.fprintf ppf "@[%a@]@." report exn

  let extract_str parse kind = function
    | {pexp_desc = Pexp_constant (Const_string (s, _)); pexp_loc = loc; _} ->
        begin try parse (Lexing.from_string s)
        with exn ->
          Location.print_error Format.std_formatter loc;
          Format.eprintf "Error while parsing a %s quotation:@.%a@." kind
            report_error exn;
          exit 2
        end
    | {pexp_loc = loc; _} ->
        Location.print_error Format.std_formatter loc;
        Format.eprintf
          "The content of this quotation must be a string literal.@.";
        exit 2

  let expander = object
    inherit Ast_mapper.mapper as super

    method! expr e =
      with_loc ~attrs:e.pexp_attributes
        (fun () ->
          match e.pexp_desc with
          | Pexp_extension("expr", e) ->
              (lifter !loc) # lift_Parsetree_expression e
          | Pexp_extension("pat", e) ->
              let p = extract_str Parse.pattern "pattern" e in
              (lifter !loc) # lift_Parsetree_pattern p
          | Pexp_extension("str", e) ->
              let p = extract_str Parse.implementation "structure" e in
              (lifter !loc) # lift_Parsetree_structure p
          | Pexp_extension("type", e) ->
              let p = extract_str Parse.core_type "type" e in
              (lifter !loc) # lift_Parsetree_core_type p
          | _ ->
              super # expr e
        )

    method! structure l =
      with_loc
        (fun () -> super # structure l)

    method! structure_item x =
      begin match x.pstr_desc with
      | Pstr_attribute x -> handle_attr x
      | _ -> ()
      end;
      super # structure_item x
  end

  let () = Ast_mapper.main expander
end
