
# module C = Char
# - : char = 'B'
#   module C' :
  sig
    external code : char -> int = "%identity"
    val chr : int -> char
    val escaped : char -> string
    val lowercase : char -> char
    val uppercase : char -> char
    type t = char
    val compare : t -> t -> int
    external unsafe_chr : int -> char = "%identity"
  end
# - : char = 'B'
#   C' Char
Characters 27-29:
  module C'' : (module C) = C';; (* fails *)
                            ^^
Error: Signature mismatch:
       Modules do not match: (module C') is not included in (module C)
#   module C'' = Char
# - : char = 'B'
#   module C3 :
  sig
    external code : char -> int = "%identity"
    val chr : int -> char
    val escaped : char -> string
    val lowercase : char -> char
    val uppercase : char -> char
    type t = char
    val compare : t -> t -> int
    external unsafe_chr : int -> char = "%identity"
  end
# - : char = 'B'
#   val f : 'a list -> int = <fun>
# val g : int list -> int = <fun>
#   module F :
  functor (X : sig  end) ->
    sig
      external code : char -> int = "%identity"
      val chr : int -> char
      val escaped : char -> string
      val lowercase : char -> char
      val uppercase : char -> char
      type t = char
      val compare : t -> t -> int
      external unsafe_chr : int -> char = "%identity"
    end
# module C4 :
  sig
    external code : char -> int = "%identity"
    val chr : int -> char
    val escaped : char -> string
    val lowercase : char -> char
    val uppercase : char -> char
    type t = char
    val compare : t -> t -> int
    external unsafe_chr : int -> char = "%identity"
  end
# - : char = 'B'
#   module G : functor (X : sig  end) -> sig module M : sig  end end
# module M : sig module M : sig  end end
#         module M' : sig module N : sig val x : int end module N' = N end
# - : int = 1
#   module M'' : sig module N' : sig val x : int end end
# - : int = 1
# module M2 : sig module N : sig val x : int end module N' = N end
# module M3 : sig module N' : sig val x : int end end
# - : int = 1
# module M3' : sig module N' : sig val x : int end end
# - : int = 1
#         module M4 : sig module N' : sig val x : int end end
# - : int = 1
#         module F :
  functor (X : sig  end) ->
    sig module N : sig val x : int end module N' = N end
# module G : functor (X : sig  end) -> sig module N' : sig val x : int end end
# module M5 : sig module N' : sig val x : int end end
# - : int = 1
#           module M :
  sig
    module D : sig val y : int end
    module N : sig val x : int end
    module N' = N
  end
#   module M1 : sig module N : sig val x : int end module N' = N end
# - : int = 1
#   module M2 : sig module N' : sig val x : int end end
# - : int = 1
#   # - : int = 1
#         module M : sig module C = Char module C' = C end
#     module M1 :
  sig module C : sig val escaped : char -> string end module C' = C end
# - : string = "A"
#   module M2 : sig module C' : sig val chr : int -> char end end
# - : char = 'B'
#   - : f:('a -> 'b) -> 'a list -> 'b list = <fun>
#   module Q = Queue
# exception QE
# - : string = "Ok"
#   module type Complex =
  sig
    type t = Complex.t = { re : float; im : float; }
    val zero : t
    val one : t
    val i : t
    val neg : t -> t
    val conj : t -> t
    val add : t -> t -> t
    val sub : t -> t -> t
    val mul : t -> t -> t
    val inv : t -> t
    val div : t -> t -> t
    val sqrt : t -> t
    val norm2 : t -> float
    val norm : t -> float
    val arg : t -> float
    val polar : float -> float -> t
    val exp : t -> t
    val log : t -> t
    val pow : t -> t -> t
  end
# module M : sig module C : Complex end
#   module C = Complex
# - : float = 1.
# type t = Complex.t = { re : float; im : float; }
val zero : t = {re = 0.; im = 0.}
val one : t = {re = 1.; im = 0.}
val i : t = {re = 0.; im = 1.}
val neg : t -> t = <fun>
val conj : t -> t = <fun>
val add : t -> t -> t = <fun>
val sub : t -> t -> t = <fun>
val mul : t -> t -> t = <fun>
val inv : t -> t = <fun>
val div : t -> t -> t = <fun>
val sqrt : t -> t = <fun>
val norm2 : t -> float = <fun>
val norm : t -> float = <fun>
val arg : t -> float = <fun>
val polar : float -> float -> t = <fun>
val exp : t -> t = <fun>
val log : t -> t = <fun>
val pow : t -> t -> t = <fun>
#   module F : functor (X : sig module C = Char end) -> sig module C = Char end
# 
